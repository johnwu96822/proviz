package viz.model;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

/**
 * One singleton VizMapStorage is used as Viz Map Model; other viz map storages
 * are used in the Viz Explorer as caches for exploring different files
 * <p>Methods postfixed with "_runtime" can only be used for lookup during runtime
 * as they look in the cache map generated by compileRuntimeMaps().</p>
 * @author JW
 */
public class VizMapStorage {
	private List<TypeViz> vizesList = new ArrayList<TypeViz>();
	private Map<String, TypeViz> topTypesVizes = new HashMap<String, TypeViz>();
	
	//Runtime map for quick access.
	private TreeMap<String, MethodViz> methodMap = new TreeMap<String, MethodViz>();
	private TreeMap<String, TypeViz> typeMap = new TreeMap<String, TypeViz>();
	
	private TreeMap<String, String> libraryMap = new TreeMap<String, String>();
	
	//The value is "1D" because no class names or packages would start with a number.
	//To avoid it being equal to a class name.
	public static final String DEFAULT_TYPE = "1D";
	public static final String MOTHER_PAINTER = "viz.painters.lib.StringPainter";

  /** Adds an association between a top-level type and its viz classes.
   * 
   * <p>Newly added TypeViz will 'replace' previous TypeViz with the same
   * key (name).</p>
   * @param typeViz association between a top-level type and its visualizations */
  public void addOrReplace (TypeViz typeViz, boolean addToEnd) {
  	if (topTypesVizes.containsKey(typeViz.getFullName())) {
  		vizesList.remove(topTypesVizes.remove(typeViz.getFullName()));
  	}
    topTypesVizes.put(typeViz.getFullName(), typeViz);
    if (addToEnd) {
    	vizesList.add(typeViz);
    }
    else {
    	vizesList.add(0, typeViz);
    }
  }
  
  /**
   * Gets a copy of the Viz list as a TypeViz array. The array returned is
   * a copy of the list, so it can be manipulated safely.
   * @return An array of top-level TypeViz's in Vizes.
   */
  public TypeViz[] getTypeList() {
  	return this.vizesList.toArray(new TypeViz[0]);
  }
  /**
   * Removes a top level (class/file level) TypeViz from Vizes but does not remove
   * the TypeViz from the file table. removeTypeFromFie() must be called to remove
   * the TypeViz from the file table.
   * @param tv The removed TypeViz; null if 
   * @return The previous TypeViz that is removed, or null tv is not in Vizes.
   */
  public TypeViz removeTypeViz(TypeViz tv) {
  	TypeViz rv = topTypesVizes.remove(tv.getFullName());
  	if (rv != null) {	
  		vizesList.remove(rv);
  	}
  	return rv;
  }
  /**
   * Checks if the TypeViz is in the top level of Vizes.
   * @param tv The TypeViz to be checked.
   * @return true if tv is the top level TypeViz in Vizes; false otherwise.
   */
  public boolean contains(TypeViz tv) {
  	return this.vizesList.contains(tv);
  }
  
  /**
   * Clears everything in Vizes.
   */
  public void clearAll() {
  	this.topTypesVizes.clear();
  	this.vizesList.clear();
  	this.methodMap.clear();
  	this.typeMap.clear();
  }

  /**
   * Gets the number of top-level TypeViz's in this FileVizesCache.
   * @return The number of top-level TypeViz's.
   */
  public int getVizSize() {
  	return this.vizesList.size();
  }
  
  /********************************************************************
   Compilation of a runtime map for quick accessing vizes
   ********************************************************************/
  
  /**
   * Compiles the runtime maps for fast access during viz lookup. 
   * Must be called before runtime starts.
   */
  public void compileRuntimeMaps() {
  	this.typeMap.clear();
  	this.methodMap.clear();
  	for (TypeViz tv : this.vizesList) {
  		addTypeAndMethodVizes(tv);
  	}
  	loadLibraryMap();
  	System.out.println("No. of types: " + typeMap.size());
  	System.out.println("No. of methods: " + methodMap.size());
  }
  
  private void loadLibraryMap() {
  	/*this.libraryMap.put("int", "viz.painters.lib.IntPainter");
  	this.libraryMap.put("java.lang.String", "viz.painters.lib.StringPainter");
  	this.libraryMap.put("int[]", "viz.painters.lib.ArrayPainter_Painter");*/
  }
  
  public String getLibraryViz(String className) {
  	String rv = libraryMap.get(className);
  	if (rv == null) {
  		rv = MOTHER_PAINTER;
  	}
  	return rv;
  }
  
  /**
   * Finds a TypeViz in this Viz Map storage
   * @param typeName
   * @return
   */
  public TypeViz findTypeViz(String typeName) {
  	for (TypeViz tv : this.vizesList) {
  		TypeViz type = findTypeViz2(tv, typeName);
  		if (type != null) {
  			return type;
  		}
  	}
  	return null;
  }
  
  private TypeViz findTypeViz2(TypeViz type, String typeName) {
		TypeViz rv = null;
		if (type.getFullName().equals(typeName)) {
			return type;
		}
		else {
			for (MethodViz mv : type.getMethodVizes()) {
				for (TypeViz tv : mv.getInnerTypeVizes()) {
					rv = findTypeViz2(tv, typeName);
					if (rv != null) {
						return rv;
					}
				}
			}
			for (TypeViz tv : type.getInnerTypeVizes()) {
				rv = findTypeViz2(tv, typeName);
				if (rv != null) {
					return rv;
				}
			}
		}
		return null;
  }

  /**
   * 11/21/2012 Maybe not needed?!?
   * @param typeName
   * @return
   */
  public TypeViz findTypeStartsWith(String typeName) {
  	for (TypeViz tv : this.vizesList) {
  		TypeViz type = findTypeViz3(tv, typeName);
  		if (type != null) {
  			return type;
  		}
  	}
  	return null;
  }
  
  private TypeViz findTypeViz3(TypeViz type, String typeName) {
		if (type.getFullName().equals(typeName)) {
			return type;
		}
		TypeViz rv = null;
		//if (type.getFullName().startsWith(typeName)) {
		//	return type;
		//}
		//else {
			for (MethodViz mv : type.getMethodVizes()) {
				for (TypeViz tv : mv.getInnerTypeVizes()) {
					rv = findTypeViz2(tv, typeName);
					if (rv != null) {
						return rv;
					}
				}
			}
			for (TypeViz tv : type.getInnerTypeVizes()) {
				rv = findTypeViz2(tv, typeName);
				if (rv != null) {
					return rv;
				}
			}
		//}
		return rv;
  }
  
  /**
   * Recursively traverses the tree of parameter, type, and adds every TypeViz and MethodViz
   * to the quick-access maps.
   * @param type
   */
  private void addTypeAndMethodVizes(TypeViz type) {
  	typeMap.put(type.getFullName(), type);
  	for (MethodViz mv : type.getMethodVizes()) {
  		methodMap.put(mv.getFullName(), mv);
  		for (TypeViz tv : mv.getInnerTypeVizes()) {
  			addTypeAndMethodVizes(tv);
  		}
  	}
  	for (TypeViz tv : type.getInnerTypeVizes()) {
  		addTypeAndMethodVizes(tv);
  	}
  }

  /**
   * Finds a MethodViz based on its Viz-formatted method ID
   * @param methodID
   * @return
   */
  public MethodViz findMethodViz_runtime(String methodID) {
  	return methodMap.get(methodID);
  }
  
  /**
   * @param methodID
   * @return An array of visualizations associated with this method. null otherwise.
   */
  public Visualization[] findMethodVCs_runtime(String methodID) {
  	MethodViz mv = methodMap.get(methodID);
  	if (mv != null) {
  		return mv.getVisualizations();
  	}
  	return new Visualization[0];
  }
  
  public TypeViz findTypeViz_runtime(String typeID) {
  	return typeMap.get(typeID);
  }
  
  public Visualization[] findTypeVCs_runtime(String typeID) {
  	TypeViz tv = typeMap.get(typeID);
  	if (tv != null) {
  		return tv.getVisualizations();
  	}
  	return new Visualization[0];
  }
  
  /**
   * @param className
   * @param fieldName
   * @return null if a corresponding FieldViz cannot be found
   */
  public FieldViz findFieldViz_runtime(String className, String fieldName) {
  	TypeViz tv = typeMap.get(className);
  	if (tv != null) {
  		return tv.getFieldViz(fieldName);
  	}
  	return null;
  }
  
  public VariableViz findVariableViz_runtime(String methodID, String varName) {
  	MethodViz mv = methodMap.get(methodID);
  	if (mv != null) {
  		return mv.getVariableViz(varName);
  	}
  	return null;
  }
  
  public Visualization[] findFieldVCs_runtime(String className, String fieldName) {
  	FieldViz fv = findFieldViz_runtime(className, fieldName);
  	if (fv != null) {
  		return fv.getVisualizations();
  	}
  	return new Visualization[0];
  }

  
  /**
   * @param methodName
   * @param vName
   * @return Never null! An array of Visualization if the VariableViz exists and is annotated with visualizations;
   * otherwise an empty Visualization array is returned.
   */
  public Visualization[] findVariableVCs_runtime(String methodName, String varName) {
  	VariableViz vv = findVariableViz_runtime(methodName, varName);
  	if (vv != null) {
  		return vv.getVisualizations();
  	}
  	return new Visualization[0];
  }
}
